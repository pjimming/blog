<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>《自己动手写docker》阅读笔记--第二章 基础技术 - 江明说|Jimmy Talk</title><meta http-equiv=x-dns-prefetch-control content="on">
<link rel=dns-prefetch href=//cdn.jsdelivr.net><link rel=dns-prefetch href=//pjimming.github.io><meta name=Description content="江明说"><meta property="og:url" content="https://blog.pjmcode.top/2024-02-26/mydocker-2/"><meta property="og:site_name" content="江明说|Jimmy Talk"><meta property="og:title" content="《自己动手写docker》阅读笔记--第二章 基础技术"><meta property="og:description" content="介绍 Docker 核心所用到的 Linux API"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-26T21:28:35+08:00"><meta property="article:modified_time" content="2024-03-13T00:12:42+08:00"><meta property="article:tag" content="Docker"><meta property="og:image" content="https://blog.pjmcode.top/2024-02-26/mydocker-2/featured-image.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.pjmcode.top/2024-02-26/mydocker-2/featured-image.png"><meta name=twitter:title content="《自己动手写docker》阅读笔记--第二章 基础技术"><meta name=twitter:description content="介绍 Docker 核心所用到的 Linux API"><meta name=application-name content="江明说"><meta name=apple-mobile-web-app-title content="江明说"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=/images/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.pjmcode.top/2024-02-26/mydocker-2/><link rel=prev href=https://blog.pjmcode.top/2024-02-26/mydocker-1/><link rel=next href=https://blog.pjmcode.top/2024-02-26/mydocker-3/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"《自己动手写docker》阅读笔记--第二章 基础技术","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.pjmcode.top\/2024-02-26\/mydocker-2\/"},"genre":"posts","keywords":"docker","wordcount":3582,"url":"https:\/\/blog.pjmcode.top\/2024-02-26\/mydocker-2\/","datePublished":"2024-02-26T21:28:35+08:00","dateModified":"2024-03-13T00:12:42+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"PanJM"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="江明说|Jimmy Talk"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/favicon.ico data-srcset="/images/favicon.ico, /images/favicon.ico 1.5x, /images/favicon.ico 2x" data-sizes=auto alt=/images/favicon.ico title=/images/favicon.ico>Jimmy Talk</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class='fa-solid fa-box-archive'></i> 所有文章 </a><a class=menu-item href=/tags/><i class='fa-solid fa-tag'></i> 标签 </a><a class=menu-item href=/categories/><i class='fa-solid fa-table-list'></i> 分类 </a><a class=menu-item href=/friend/><i class='fa-solid fa-user-group'></i> 友链 </a><a class=menu-item href=/book-list/><i class='fa-solid fa-book'></i> 书单 </a><a class=menu-item href=/about/><i class='fa-regular fa-address-card'></i> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="江明说|Jimmy Talk"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/favicon.ico data-srcset="/images/favicon.ico, /images/favicon.ico 1.5x, /images/favicon.ico 2x" data-sizes=auto alt=/images/favicon.ico title=/images/favicon.ico>Jimmy Talk</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title><i class='fa-solid fa-box-archive'></i>所有文章</a><a class=menu-item href=/tags/ title><i class='fa-solid fa-tag'></i>标签</a><a class=menu-item href=/categories/ title><i class='fa-solid fa-table-list'></i>分类</a><a class=menu-item href=/friend/ title><i class='fa-solid fa-user-group'></i>友链</a><a class=menu-item href=/book-list/ title><i class='fa-solid fa-book'></i>书单</a><a class=menu-item href=/about/ title><i class='fa-regular fa-address-card'></i>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">《自己动手写docker》阅读笔记--第二章 基础技术</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/pjimming/ title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>PanJM</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/docker/><i class="far fa-folder fa-fw" aria-hidden=true></i>Docker</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2024-02-26>2024-02-26</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 3582 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 8 分钟&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=/2024-02-26/mydocker-2/featured-image.png data-srcset="/2024-02-26/mydocker-2/featured-image.png, /2024-02-26/mydocker-2/featured-image.png 1.5x, /2024-02-26/mydocker-2/featured-image.png 2x" data-sizes=auto alt=/2024-02-26/mydocker-2/featured-image.png title=/2024-02-26/mydocker-2/featured-image.png width=1410 height=738></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#linux-namespace>Linux Namespace</a><ul><li><a href=#uts-namespace>UTS Namespace</a></li><li><a href=#ipc-namespace>IPC Namespace</a></li><li><a href=#pid-namespace>PID Namespace</a></li><li><a href=#mount-namespace>Mount Namespace</a><ul><li><a href=#mount-命令>mount 命令</a></li><li><a href=#umount-命令>umount 命令</a></li><li><a href=#使用示例>使用示例</a></li></ul></li><li><a href=#user-namespace>User Namespace</a></li><li><a href=#network-namespace>Network Namespace</a></li></ul></li><li><a href=#linux-cgroups>Linux Cgroups</a><ul><li><a href=#cgroup-的三个组件>cgroup 的三个组件：</a><ul><li><a href=#三者之间的关系>三者之间的关系</a></li></ul></li><li><a href=#kernel-接口>Kernel 接口</a></li><li><a href=#docker-如何使用-cgroups>Docker 如何使用 Cgroups？</a></li></ul></li><li><a href=#union-file-system>Union File System</a><ul><li><a href=#aufs>AUFS</a><ul><li><a href=#image-layer-与-aufs>image Layer 与 AUFS</a><ul><li><a href=#image-layer镜像层-><strong>Image Layer（镜像层）</strong> ：</a></li><li><a href=#image-layer-与-aufs-是如何通过共享文件和文件夹实现镜像存储的>image layer 与 AUFS 是如何通过共享文件和文件夹实现镜像存储的？</a></li></ul></li><li><a href=#container-layer-与-aufs>container layer 与 AUFS</a><ul><li><a href=#container-layer容器层-><strong>Container Layer（容器层）</strong> ：</a></li></ul></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fas fa-exclamation-triangle fa-fwwarning"></i>警告<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><span>这篇文章最后修改于</span>
<span class=timeago datetime=2024-03-13T00:12:42 title="March 13, 2024">March 13, 2024</span>
<span>，请鉴别其时效性，以免造成不必要的麻烦。</span></div></div></div><p>介绍 Docker 核心所用到的 Linux API</p><hr><h2 id=linux-namespace>Linux Namespace</h2><p>可以隔离一系列系统资源，例如 PID、UID、Network。</p><ul><li><p>chroot 隔离文件:</p><ul><li><a href=https://www.cnblogs.com/charlieroro/p/9259675.html target=_blank rel="noopener noreffer">chroot 的用法</a></li><li>作用：改变进程的根目录，使它不能访问该目录之外的其他文件。即切换进程的 rootfs 常用命令 chroot</li></ul></li><li><p>常见管理 namespace 的 API</p><ul><li>clone()：传递特定的 flag(CLONE_NEW*)标志给 clone()，则会根据每个标志创建对应新的 namespace 并且将子进程添加为其的成员。</li><li>setns()：允许一个进程加入一个已存在的 namespace 中。</li><li>unshare()：移出某个 Namespace，允许进程取消其执行的上下文，可以利用此系统调用让当前进程移动到一个新的 namespace 中。（unshare &ndash;pid: Unshare the pid namespace）</li><li>execv()：在子进程中运行一个新的程序</li></ul></li></ul><p>当前 Linux 一共实现了 6 种不同类型的 Namespace</p><table><thead><tr><th>Namespace 类型</th><th>系统调用参数</th></tr></thead><tbody><tr><td>Mount Namespace</td><td>CLONE_NEWNS</td></tr><tr><td>UTS Namespace</td><td>CLONE_NEWUTS</td></tr><tr><td>IPC Namespace</td><td>CLONE_NEWIPC</td></tr><tr><td>PID Namespace</td><td>CLONE_NEWPID</td></tr><tr><td>Network Namespace</td><td>CLONE_NEWNET</td></tr><tr><td>User Namespace</td><td>CLONE_NEWUSER</td></tr></tbody></table><h3 id=uts-namespace>UTS Namespace</h3><p>用来隔离 hostname 和 domain name。在 UTS Namespace 里，每个 Namespace 允许有自己的 hostname。</p><h3 id=ipc-namespace>IPC Namespace</h3><p>隔离进程间通信资源，即隔离 System V IPC 和 POSIX message queues。使用<code>ipcs -q</code>验证。</p><h3 id=pid-namespace>PID Namespace</h3><p>用来隔离进程 ID，<code>echo $$</code>显示当前 pid 为 1，但是不能用 ps 或 top 命令，因为这些命令使用/proc 里的内容。</p><h3 id=mount-namespace>Mount Namespace</h3><p>用于隔离各个进程看到的挂载点视图，不同 namespace 的进程中，看到的文件层次是不一样的。在 Mount Namespace 中，调用<code>mount()</code>和<code>umount()</code>仅仅会影响当前 namespace 内的文件系统，对全局的文件系统不会造成影响。</p><p><code>mount</code> 和 <code>umount</code> 是 Linux 系统中用于挂载和卸载文件系统的命令。</p><h4 id=mount-命令>mount 命令</h4><p><code>mount</code> 命令用于将文件系统挂载到指定的挂载点上，其基本语法为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mount [options] &lt;device&gt; &lt;mountpoint&gt;
</span></span></code></pre></td></tr></table></div></div><p>其中：</p><ul><li><code>&lt;device></code>：表示要挂载的设备或文件系统的路径，可以是硬盘分区、软件 RAID 设备、CD-ROM 等。</li><li><code>&lt;mountpoint></code>：表示挂载的目标路径，也就是文件系统挂载的位置。</li></ul><p><code>mount</code> 命令的主要作用包括：</p><ol><li>将文件系统挂载到指定的挂载点上，使得文件系统中的内容可以被访问。</li><li>可以通过不同的选项对挂载的行为进行配置，比如读写权限、文件系统类型等。</li></ol><h4 id=umount-命令>umount 命令</h4><p><code>umount</code> 命令用于卸载已经挂载的文件系统，其基本语法为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>umount &lt;mountpoint&gt;
</span></span></code></pre></td></tr></table></div></div><p>其中：</p><ul><li><code>&lt;mountpoint></code>：表示已经挂载的文件系统的挂载点。</li></ul><p><code>umount</code> 命令的主要作用是将指定挂载点上的文件系统卸载，使得该挂载点上的内容不再可见，并释放相关资源。</p><h4 id=使用示例>使用示例</h4><ol><li><p>挂载一个设备到指定挂载点：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mount /dev/sdb1 /mnt
</span></span></code></pre></td></tr></table></div></div><p>这会将 <code>/dev/sdb1</code>​ 分区挂载到 <code>/mnt</code>​ 目录上。</p></li><li><p>使用选项挂载一个文件系统：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mount -t ext4 /dev/sdc1 /mnt
</span></span></code></pre></td></tr></table></div></div><p>这会将 <code>/dev/sdc1</code>​ 分区以 ext4 文件系统类型挂载到 <code>/mnt</code>​ 目录上。</p></li><li><p>卸载一个已挂载的文件系统：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>umount /mnt
</span></span></code></pre></td></tr></table></div></div><p>这会将 <code>/mnt</code>​ 目录上的文件系统卸载。</p></li><li><p>这条命令 <code>mount -t proc proc /proc</code>​ 的作用是将虚拟文件系统 proc 挂载到系统中的 <code>/proc</code>​ 目录上。</p><p>具体而言，这个命令完成了以下几个作用：</p><ol><li>​<code>-t proc</code>​ 指定了挂载的文件系统类型为 proc，即虚拟文件系统 proc。proc 文件系统是一个特殊的文件系统，它不存储在磁盘上，而是在内存中由内核动态创建的，用于提供进程信息和内核信息等。</li><li>​<code>proc</code>​ 是要挂载的文件系统的源，通常在 Linux 中，虚拟文件系统 proc 不需要一个实际的设备来挂载，因此通常直接写 <code>proc</code>​。</li><li>​<code>/proc</code>​ 是挂载点，也就是挂载操作的目标路径。在 Linux 系统中，<code>/proc</code>​ 目录用于向用户和用户空间程序提供关于系统内核和进程的信息。挂载 proc 文件系统到 <code>/proc</code>​ 目录后，可以通过 <code>/proc</code>​ 目录来访问和获取系统内核和进程的各种信息。</li></ol><p>因此，这条命令的作用是将 Linux 内核提供的 proc 文件系统挂载到系统中的 <code>/proc</code>​ 目录，以便用户和程序可以通过 <code>/proc</code>​ 目录来查看和获取关于系统内核和进程的信息。</p></li></ol><p>这些命令对于管理 Linux 系统中的文件系统非常重要，能够方便地实现文件系统的挂载和卸载操作。</p><h3 id=user-namespace>User Namespace</h3><p>主要用来隔离用户的用户组 ID，非 root 用户可以在自己创建的 User Namespace 里拥有 root 权限。使用<code>id</code>命令进行验证。</p><p>​
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211554-rfulanh.png data-srcset="https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211554-rfulanh.png, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211554-rfulanh.png 1.5x, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211554-rfulanh.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211554-rfulanh.png title=image-20240215211554-rfulanh.png>​</p><h3 id=network-namespace>Network Namespace</h3><p>用来隔离网络设备、IP 地址端口。使 Namespace 拥有独立的网络设备。运行<code>ifconfig</code>​ 没有任何网络设备。</p><p>​
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211519-jdy9y5h.png data-srcset="https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211519-jdy9y5h.png, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211519-jdy9y5h.png 1.5x, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211519-jdy9y5h.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211519-jdy9y5h.png title=image-20240215211519-jdy9y5h.png>​</p><h2 id=linux-cgroups>Linux Cgroups</h2><p><strong>Ubuntu 安装 cgroup</strong>：<code>sudo apt install cgroup-tools</code></p><p>全称 Control Group，对子系统提供精细化的控制能力，例如 cpu、内存、io、网络。</p><p>基于 cgroup virtual filesystem，这个系统文件一般挂载在 <code>/sys/fs/cgroup</code> 目录下。</p><p>通过将 pid 加入到对应<code>cgroup.procs</code>​，即可对进程所拥有的资源进行限制。</p><p>​
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211541-a6p5htt.png data-srcset="https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211541-a6p5htt.png, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211541-a6p5htt.png 1.5x, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211541-a6p5htt.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211541-a6p5htt.png title=image-20240215211541-a6p5htt.png>​</p><p>cgroup 提供<code>cpu.cfs_quota_us</code>和<code>cpu.cfs_period_us</code>两个参数限制 CPU 占用的上限。</p><ul><li><code>cpu.cfs_quota_us</code>: 运行周期，单位为微秒，默认 100,000us，即 100ms。</li><li><code>cpu.cfs_quota_us</code>: 运行周期内这个 cgroup 组所有进程可运行的时间总量，单位为微秒，默认值为-1，即不设置上限。</li></ul><h3 id=cgroup-的三个组件>cgroup 的三个组件：</h3><ol><li><strong>Subsystem（子系统）</strong> ：
子系统是 cgroups 的核心组件之一，用于控制和管理特定类型的资源。每个子系统负责监控和限制一种或多种资源，如 CPU、内存、磁盘 I/O、网络带宽等。不同的子系统对应不同的资源类型，例如，<code>cpu</code> 子系统用于限制 CPU 使用量，<code>memory</code> 子系统用于限制内存使用量，<code>blkio</code> 子系统用于限制磁盘 I/O 等。通过配置 cgroups 中的子系统，可以为进程组分配和限制资源的使用。</li><li><strong>Hierarchy（层级）</strong> ：
层级是 cgroups 中的一个概念，用于组织和管理 cgroups。一个 cgroups 层级可以包含多个 cgroups 组，并且可以为每个 cgroups 组分配一定数量的资源。每个 cgroups 层级由一个或多个子系统组成，这些子系统共同为 cgroups 中的进程组提供资源控制。层级可以以树状结构组织，每个层级都有一个顶层的根节点。</li><li><strong>Control Interface（控制接口）</strong> ：
控制接口是用户用于管理 cgroups 的接口，它允许用户创建、修改、删除 cgroups，并设置相应的资源限制和参数。通过控制接口，用户可以在运行时动态地管理 cgroups，实现对进程组资源的有效控制和管理。控制接口通常通过文件系统暴露，用户可以通过文件系统操作来管理 cgroups。常见的控制接口包括在 <code>/sys/fs/cgroup</code> 或 <code>/sys/fs/cgroup/&lt;subsystem></code> 下的文件和目录。</li></ol><h4 id=三者之间的关系>三者之间的关系</h4><ul><li>系统创建新的 hierarchy，系统中所有的进程都会加入这个 hierarchy 的 cgroup 根节点，这个根节点由 hierarchy 默认创建。</li><li>一个 subsystem 只能附加在一个 hierarchy 上</li><li>一个 hierarchy 可以附加多个 subsystem</li><li>一个进程可以作为多个 cgroup 成员，但是这些 cgroup 必须在不同的 hierarchy 中</li><li>一个进程 fork 出子进程时，子进程与父进程在同一个 cgroup 里，也可以迁移到其他 cgroup 中</li></ul><h3 id=kernel-接口>Kernel 接口</h3><ol><li><p>创建并挂载一个 hierarchy（cgroup 树）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mkdir cgroups-test
</span></span><span class=line><span class=cl>sudo mount -t cgroups -o none,name<span class=o>=</span>cgroups-test cgroups-test ./cgroups-test
</span></span></code></pre></td></tr></table></div></div><p>​
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211604-32bpo4i.png data-srcset="https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211604-32bpo4i.png, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211604-32bpo4i.png 1.5x, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211604-32bpo4i.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211604-32bpo4i.png title=image-20240215211604-32bpo4i.png>​</p></li><li><p>在根节点上扩展出两个子 cgroup</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>cd</span> cgroups-test
</span></span><span class=line><span class=cl>sudo mkdir cgroups-1
</span></span><span class=line><span class=cl>sudo mkdir cgroups-2
</span></span></code></pre></td></tr></table></div></div><p>​
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211619-nvtg520.png data-srcset="https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211619-nvtg520.png, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211619-nvtg520.png 1.5x, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211619-nvtg520.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211619-nvtg520.png title=image-20240215211619-nvtg520.png>​</p></li><li><p>在 cgroup 中添加和移动进程</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$$</span>
</span></span><span class=line><span class=cl>cat /proc/<span class=nv>$$</span>/cgroups
</span></span><span class=line><span class=cl>sudo sh -c <span class=s2>&#34;echo </span><span class=nv>$$</span><span class=s2> &gt; cgroup-1/tasks&#34;</span>
</span></span><span class=line><span class=cl>cat /proc/<span class=nv>$$</span>/cgroups
</span></span></code></pre></td></tr></table></div></div><p>执行这段命令可以发现进程 76284 被加到了 cgroup-test:/cgroup-1 中</p><p>​
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211625-cmhsg00.png data-srcset="https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211625-cmhsg00.png, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211625-cmhsg00.png 1.5x, https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211625-cmhsg00.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/pjimming/mydocker/main/docs/assets/image-20240215211625-cmhsg00.png title=image-20240215211625-cmhsg00.png>​</p></li><li><p>通过 subsystem 限制 cgroup 的资源</p></li></ol><h3 id=docker-如何使用-cgroups>Docker 如何使用 Cgroups？</h3><p>docker 为每个容器创建 cgroup，并通过 cgroup 去配置资源限制和资源监控</p><h2 id=union-file-system>Union File System</h2><p>Union File System，简称 UnionFS，是把其他文件系统联合到一个<strong>联合挂载点</strong>的文件系统服务。unionfs 用到了一个重要的资源管理技术，叫写时复制。</p><h3 id=aufs>AUFS</h3><p>AUFS 重写了早期的 UnionFS1.x，改进了可靠性与性能。</p><h4 id=image-layer-与-aufs>image Layer 与 AUFS</h4><h5 id=image-layer镜像层-><strong>Image Layer（镜像层）</strong> ：</h5><p>Docker 镜像是由多个层组成的，每个镜像层都是一个只读的文件系统快照，包含了一组文件和目录。每个镜像层都有一个唯一的标识符，通常是基于其内容的哈希值。镜像层之间通过父子关系连接，使得 Docker 可以有效地共享和重用相同的文件系统层。当创建一个新的镜像时，Docker 会根据 Dockerfile 中的指令（比如 RUN、COPY、ADD 等）创建新的层，并在其上叠加已有的层，形成一个新的镜像。</p><h5 id=image-layer-与-aufs-是如何通过共享文件和文件夹实现镜像存储的>image layer 与 AUFS 是如何通过共享文件和文件夹实现镜像存储的？</h5><p>Image Layer（镜像层）和 AUFS（Another Union File System）通过共享文件和文件夹的方式来实现镜像存储和管理的。</p><p>在 Docker 中，当创建一个新的镜像时，Docker 会根据 Dockerfile 中的指令逐步构建镜像，并生成一系列的镜像层。每个镜像层都包含了一组文件和目录的快照。这些文件和目录可以是通过 <code>RUN</code>​、<code>COPY</code>​、<code>ADD</code>​ 等指令添加到镜像中的。</p><p>AUFS 提供了一种联合挂载的技术，允许将多个只读的镜像层和一个可写的容器层组合在一起，形成一个完整的容器文件系统。AUFS 将这些不同的层叠加在一起，形成一个逻辑的文件系统视图。对于容器内的操作，AUFS 会根据层的优先级和可写性，选择相应的层来执行读取和写入操作。</p><p>在 AUFS 中，镜像层之间通过共享文件和文件夹来实现存储的。具体来说，AUFS 使用了一种称为写时复制（copy-on-write）的技术。当容器需要修改一个文件或目录时，AUFS 不会直接修改原始的文件或目录，而是创建一个副本并将修改写入副本中。这样做的好处是，多个容器可以共享相同的只读镜像层，而不会相互影响，从而节省存储空间和提高效率。</p><h4 id=container-layer-与-aufs>container layer 与 AUFS</h4><h5 id=container-layer容器层-><strong>Container Layer（容器层）</strong> ：</h5><p>容器层是 Docker 容器的可写文件系统层，用于存储容器运行时产生的文件和目录，以及容器内部的变化。当您在容器中创建、修改或删除文件时，这些更改都会记录在容器层中。容器层使得 Docker 可以实现容器的状态隔离和持久化，即使容器被删除，容器层中的数据也可以被保留下来。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2024-03-13&nbsp;<a class=git-hash href=https://github.com/pjimming/blog/commit/1c115203430829ae7510133fab1bb6fca881f8d8 target=_blank title="commit by pjm(2556323541@qq.com) 1c115203430829ae7510133fab1bb6fca881f8d8: post: blog/20240312">
<i class="fas fa-hashtag fa-fw" aria-hidden=true></i>1c11520</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/2024-02-26/mydocker-2/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://blog.pjmcode.top/2024-02-26/mydocker-2/ data-title="《自己动手写docker》阅读笔记--第二章 基础技术" data-hashtags=docker><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://blog.pjmcode.top/2024-02-26/mydocker-2/ data-hashtag=docker><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://blog.pjmcode.top/2024-02-26/mydocker-2/ data-title="《自己动手写docker》阅读笔记--第二章 基础技术"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://blog.pjmcode.top/2024-02-26/mydocker-2/ data-title="《自己动手写docker》阅读笔记--第二章 基础技术"><i data-svg-src=/lib/simple-icons/icons/line.min.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://blog.pjmcode.top/2024-02-26/mydocker-2/ data-title="《自己动手写docker》阅读笔记--第二章 基础技术" data-image=featured-image.png><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/docker/>Docker</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2024-02-26/mydocker-1/ class=prev rel=prev title="《自己动手写docker》阅读笔记--第一章 容器与开发语言"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>《自己动手写docker》阅读笔记--第一章 容器与开发语言</a>
<a href=/2024-02-26/mydocker-3/ class=next rel=next title="《自己动手写docker》阅读笔记--第三章 构造容器">《自己动手写docker》阅读笔记--第三章 构造容器<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app>Giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><span id=run-time></span></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2024 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=备案编号" target=_blank>浙ICP备2024074882号</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/plugins/zoom/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{giscus:{category:"Announcements",categoryId:"DIC_kwDOLZmgDc4Cdm7x",darkTheme:"preferred_color_scheme",emitMetadata:"0",inputPosition:"top",lang:"zh-CN",lazyLoading:!1,lightTheme:"light",mapping:"pathname",reactionsEnabled:"1",repo:"pjimming/blog-comment",repoId:"R_kgDOLZmgDQ"}},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript src=https://cdn.staticfile.net/jquery/2.2.4/jquery.min.js></script><script type=text/javascript src=/js/custom.js></script></body></html>