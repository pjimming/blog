<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Golang性能分析工具之pprof实战 - 江明说|Jimmy Talk</title><meta http-equiv=x-dns-prefetch-control content="on">
<link rel=dns-prefetch href=//cdn.jsdelivr.net><link rel=dns-prefetch href=//pjimming.github.io><meta name=Description content="江明说"><meta property="og:url" content="https://blog.pjmcode.top/2024-03-24/pprof/"><meta property="og:site_name" content="江明说|Jimmy Talk"><meta property="og:title" content="Golang性能分析工具之pprof实战"><meta property="og:description" content="通过实战来了解、熟悉 pprof 工具的使用"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-24T10:35:19+08:00"><meta property="article:modified_time" content="2024-07-07T10:07:16+08:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Pprof"><meta property="article:tag" content="性能优化"><meta property="article:tag" content="实战"><meta property="og:image" content="https://blog.pjmcode.top/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.pjmcode.top/logo.png"><meta name=twitter:title content="Golang性能分析工具之pprof实战"><meta name=twitter:description content="通过实战来了解、熟悉 pprof 工具的使用"><meta name=application-name content="江明说"><meta name=apple-mobile-web-app-title content="江明说"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=/images/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.pjmcode.top/2024-03-24/pprof/><link rel=prev href=https://blog.pjmcode.top/2024-03-21/instantid/><link rel=next href=https://blog.pjmcode.top/2024-03-24/pprof-theory/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Golang性能分析工具之pprof实战","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.pjmcode.top\/2024-03-24\/pprof\/"},"genre":"posts","keywords":"golang, pprof, 性能优化, 实战","wordcount":4481,"url":"https:\/\/blog.pjmcode.top\/2024-03-24\/pprof\/","datePublished":"2024-03-24T10:35:19+08:00","dateModified":"2024-07-07T10:07:16+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"PanJM"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="江明说|Jimmy Talk"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/favicon.ico data-srcset="/images/favicon.ico, /images/favicon.ico 1.5x, /images/favicon.ico 2x" data-sizes=auto alt=/images/favicon.ico title=/images/favicon.ico>Jimmy Talk</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class='fa-solid fa-box-archive'></i> 所有文章 </a><a class=menu-item href=/tags/><i class='fa-solid fa-tag'></i> 标签 </a><a class=menu-item href=/categories/><i class='fa-solid fa-table-list'></i> 分类 </a><a class=menu-item href=/friend/><i class='fa-solid fa-user-group'></i> 友链 </a><a class=menu-item href=/book-list/><i class='fa-solid fa-book'></i> 书单 </a><a class=menu-item href=/about/><i class='fa-regular fa-address-card'></i> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="江明说|Jimmy Talk"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/favicon.ico data-srcset="/images/favicon.ico, /images/favicon.ico 1.5x, /images/favicon.ico 2x" data-sizes=auto alt=/images/favicon.ico title=/images/favicon.ico>Jimmy Talk</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title><i class='fa-solid fa-box-archive'></i>所有文章</a><a class=menu-item href=/tags/ title><i class='fa-solid fa-tag'></i>标签</a><a class=menu-item href=/categories/ title><i class='fa-solid fa-table-list'></i>分类</a><a class=menu-item href=/friend/ title><i class='fa-solid fa-user-group'></i>友链</a><a class=menu-item href=/book-list/ title><i class='fa-solid fa-book'></i>书单</a><a class=menu-item href=/about/ title><i class='fa-regular fa-address-card'></i>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Golang性能分析工具之pprof实战</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/pjimming/ title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>PanJM</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/golang/><i class="far fa-folder fa-fw" aria-hidden=true></i>Golang</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2024-03-24>2024-03-24</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 4481 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 9 分钟&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7smz4kuu12.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7smz4kuu12.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7smz4kuu12.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7smz4kuu12.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7smz4kuu12.webp title=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7smz4kuu12.webp></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#环境搭建>环境搭建</a><ul><li><a href=#图形化依赖安装>图形化依赖安装</a></li><li><a href=#获取炸弹并运行>获取炸弹并运行</a></li></ul></li><li><a href=#指标查看>指标查看</a></li><li><a href=#排查-cpu-占用过高>排查 CPU 占用过高</a></li><li><a href=#排查内存占用过高>排查内存占用过高</a></li><li><a href=#排查频繁内存回收>排查频繁内存回收</a></li><li><a href=#排查协程泄漏问题>排查协程泄漏问题</a></li><li><a href=#排查锁的争用关系>排查锁的争用关系</a></li><li><a href=#排查协程阻塞问题>排查协程阻塞问题</a></li><li><a href=#排查内存泄漏>排查内存泄漏</a></li><li><a href=#总结>总结</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></div><div class=content id=content><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fas fa-exclamation-triangle fa-fwwarning"></i>警告<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><span>这篇文章最后修改于</span>
<span class=timeago datetime=2024-07-07T10:07:16 title="July 7, 2024">July 7, 2024</span>
<span>，请鉴别其时效性，以免造成不必要的麻烦。</span></div></div></div><p>通过实战来了解、熟悉 pprof 工具的使用</p><hr><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw" aria-hidden=true></i>引言<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><p>benchmark(基准测试) 可以度量某个函数或方法的性能，也就是说，如果我们知道性能的瓶颈点在哪里，benchmark 一是个非常好的方式。但是面对一个未知的程序，如何去分析这个程序的性能，并找到瓶颈点呢？</p><p>pprof 就是用来解决这个问题的。pprof 包含两部分：</p><ul><li>编译到程序中的 <code>runtime/pprof</code> 包</li><li>性能剖析工具 <code>go tool pprof</code></li></ul><p>pprof 主要可以分析 CPU、内存的使用情况、阻塞情况、Goroutine 的堆栈信息以及锁争用情况等性能问题。</p><p>该博客涉及到的项目代码：<a href=https://github.com/pjimming/go-pprof-practice target=_blank rel="noopener noreffer">https://github.com/pjimming/go-pprof-practice</a></p></div></div></div><h2 id=环境搭建>环境搭建</h2><p>从 GitHub 上获取一个性能堪忧的项目，有助于更好的使用 pprof 监控到程序的性能问题。</p><blockquote><p>务必确保你是在个人机器上运行“炸弹”的，能接受机器死机重启的后果（虽然这发生的概率很低）。请你务必不要在危险的边缘试探，比如在线上服务器运行这个程序。</p></blockquote><h3 id=图形化依赖安装>图形化依赖安装</h3><p>选择合适的包安装工具，安装图形化依赖 <a href=https://graphviz.gitlab.io/ target=_blank rel="noopener noreffer">graphviz</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>brew install graphviz <span class=c1># macos</span>
</span></span><span class=line><span class=cl>apt install graphviz <span class=c1># ubuntu</span>
</span></span><span class=line><span class=cl>yum install graphviz <span class=c1># centos</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=获取炸弹并运行>获取炸弹并运行</h3><p>Linux(Ubuntu) 系统下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git clone git@github.com:pjimming/go-pprof-practice.git
</span></span><span class=line><span class=cl><span class=nb>cd</span> go-pprof-practice
</span></span><span class=line><span class=cl>make run
</span></span></code></pre></td></tr></table></div></div><h2 id=指标查看>指标查看</h2><p>保持程序的运行，打开浏览器访问 <a href=http://localhost:6060/debug/pprof/ target=_blank rel="noopener noreffer">http://localhost:6060/debug/pprof/</a>，可以看到如下的页面：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4xuaysn21a.webp title="/debug/pprof 页面" data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4xuaysn21a.webp data-sub-html="<h2> </h2><p>/debug/pprof 页面</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4xuaysn21a.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4xuaysn21a.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4xuaysn21a.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4xuaysn21a.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4xuaysn21a.webp></a><figcaption class=image-caption>/debug/pprof 页面</figcaption></figure></p><p>页面上展示了采样的信息，分别是：</p><table><thead><tr><th style=text-align:center>类型</th><th style=text-align:center>描述</th></tr></thead><tbody><tr><td style=text-align:center>allocs</td><td style=text-align:center>内存分配情况的采样信息</td></tr><tr><td style=text-align:center>block</td><td style=text-align:center>阻塞操作情况的采样信息</td></tr><tr><td style=text-align:center>cmdline</td><td style=text-align:center>显示程序启动命令及参数</td></tr><tr><td style=text-align:center>goroutine</td><td style=text-align:center>当前所有协程的堆栈信息</td></tr><tr><td style=text-align:center>heap</td><td style=text-align:center>堆上内存使用情况的采样信息</td></tr><tr><td style=text-align:center>mutex</td><td style=text-align:center>锁争用情况的采样信息</td></tr><tr><td style=text-align:center>profile</td><td style=text-align:center>CPU 占用情况的采样信息</td></tr><tr><td style=text-align:center>threadcreate</td><td style=text-align:center>系统线程创建情况的采样信息</td></tr><tr><td style=text-align:center>trace</td><td style=text-align:center>程序运行跟踪信息</td></tr></tbody></table><p>由于直接阅读采样信息缺乏直观性，我们需要借助 <code>go tool pprof</code> 命令来排查问题，这个命令是 go 原生自带的，所以不用额外安装。</p><h2 id=排查-cpu-占用过高>排查 CPU 占用过高</h2><p>执行 <code>top</code> 命令，可以发现当前程序占用的 CPU 过高，如下图所示：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.9dcq427mdp.webp title=top命令：查看当前资源使用情况 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.9dcq427mdp.webp data-sub-html="<h2> </h2><p>top命令：查看当前资源使用情况</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.9dcq427mdp.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.9dcq427mdp.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.9dcq427mdp.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.9dcq427mdp.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.9dcq427mdp.webp></a><figcaption class=image-caption>top命令：查看当前资源使用情况</figcaption></figure></p><p>此时使用 <code>go tool pprof</code> 命令对 CPU 运行情况进行采样，使用下列命令，每 10s 对 CPU 使用情况进行采样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go tool pprof <span class=s2>&#34;http://localhost:6060/debug/pprof/profile?seconds=10&#34;</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>因为我们这里采集的是 profile 类型，因此需要等待一定的时间来对 CPU 做采样。你可以通过查询字符串中 seconds 参数来调节采样时间的长短（单位为秒）</p></blockquote><p>等待 10s 左右之后，进入一个可交互的命令行页面：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5mnkitnsyl.webp title=执行命令进入CPU采样的可交互命令 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5mnkitnsyl.webp data-sub-html="<h2> </h2><p>执行命令进入CPU采样的可交互命令</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5mnkitnsyl.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5mnkitnsyl.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5mnkitnsyl.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5mnkitnsyl.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5mnkitnsyl.webp></a><figcaption class=image-caption>执行命令进入CPU采样的可交互命令</figcaption></figure></p><p>执行 <code>top</code> 命令，查看 CPU 调用较高的函数：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.41xtjcsnse.webp title="pprof中执行<code>top</code>命令" data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.41xtjcsnse.webp data-sub-html="<h2> </h2><p>pprof中执行<code>top</code>命令</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.41xtjcsnse.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.41xtjcsnse.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.41xtjcsnse.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.41xtjcsnse.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.41xtjcsnse.webp></a><figcaption class=image-caption>pprof中执行<code>top</code>命令</figcaption></figure></p><p>参数说明：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>flat</td><td>当前函数本身的执行耗时</td></tr><tr><td>flat%</td><td>flat 占 CPU 总时间的比例</td></tr><tr><td>sum%</td><td>上面每一行的 flat%总和</td></tr><tr><td>cum</td><td>指当前函数本身加上其调用函数的总耗时</td></tr><tr><td>cum%</td><td>cum 占 CUP 总时间的比例</td></tr></tbody></table><p>其中：</p><ul><li>$flat==cum$ 时，函数中没有调用其他函数</li><li>$flat==0$ 时，函数中只有其他函数的调用</li></ul><p>发现是 Eat 函数调用 CPU 过高，此时执行 <code>list Eat</code> 命令，查看问题具体在代码的哪一个位置：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8dwmqwebgx.webp title="pprof中执行<code>list Eat</code>命令" data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8dwmqwebgx.webp data-sub-html="<h2> </h2><p>pprof中执行<code>list Eat</code>命令</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8dwmqwebgx.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8dwmqwebgx.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8dwmqwebgx.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8dwmqwebgx.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8dwmqwebgx.webp></a><figcaption class=image-caption>pprof中执行<code>list Eat</code>命令</figcaption></figure></p><p>从输出结果里可以看到对应的文件为 <code>/animal/felidae/tiger/tiger.go</code>，而且具体的代码行为 24 行的一百亿次 <code>for</code> 循环导致的。</p><p>我们尝试注释这段代码，并且重新编译运行，看看 CPU 使用率是否会下降</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>Tiger</span><span class=p>)</span> <span class=nf>Eat</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nf>Name</span><span class=p>(),</span> <span class=s>&#34;eat&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>//loop := 10000000000
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//for i := 0; i &lt; loop; i++ {
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//	// do nothing
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>中断之前的程序，重新执行 <code>make run</code> 命令，可以发现 CPU 的占用情况下降了。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.lvhr9tcf6.webp title=top命令中，进程占用CPU出现下降情况 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.lvhr9tcf6.webp data-sub-html="<h2> </h2><p>top命令中，进程占用CPU出现下降情况</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.lvhr9tcf6.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.lvhr9tcf6.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.lvhr9tcf6.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.lvhr9tcf6.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.lvhr9tcf6.webp></a><figcaption class=image-caption>top命令中，进程占用CPU出现下降情况</figcaption></figure></p><h2 id=排查内存占用过高>排查内存占用过高</h2><p>根据上图执行的 <code>top</code> 命令来看，发现程序当前占用的内存较高，我们可以通过 pprof 的 heap 来查看堆内存使用情况</p><p>执行命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go tool pprof <span class=s2>&#34;http://localhost:6060/debug/pprof/heap&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>然后执行 <code>top</code> 命令，发现 Steal 占用大量的内存情况：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.969i8nhhu9.webp title="pprof中执行<code>top</code>命令" data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.969i8nhhu9.webp data-sub-html="<h2> </h2><p>pprof中执行<code>top</code>命令</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.969i8nhhu9.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.969i8nhhu9.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.969i8nhhu9.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.969i8nhhu9.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.969i8nhhu9.webp></a><figcaption class=image-caption>pprof中执行<code>top</code>命令</figcaption></figure></p><p>执行 <code>list Steal</code> 命令，查看代码细节：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7egjdqybji.webp title="pprof中执行<code>list Steal</code>命令" data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7egjdqybji.webp data-sub-html="<h2> </h2><p>pprof中执行<code>list Steal</code>命令</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7egjdqybji.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7egjdqybji.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7egjdqybji.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7egjdqybji.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7egjdqybji.webp></a><figcaption class=image-caption>pprof中执行<code>list Steal</code>命令</figcaption></figure></p><p>根据代码细节的问题，去按照实际情况解决即可。不过我们是否还记得之前安装的图形化依赖，可以通过图形化的方式去查看性能问题。因为 web 页面可视化的方式排查比较直观，因此命令行排查的方式就不再展开了，输入以下命令可以看到堆内存的占用情况：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go tool pprof -http<span class=o>=</span>:8080 <span class=s2>&#34;http://localhost:6060/debug/pprof/heap&#34;</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>这个命令中 http 选项将会启动一个 web 服务器并自动打开网页。其值为 web 服务器的 endpoint</p></blockquote><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbibdi42.webp title=图形化页面 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbibdi42.webp data-sub-html="<h2> </h2><p>图形化页面</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbibdi42.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbibdi42.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbibdi42.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbibdi42.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbibdi42.webp></a><figcaption class=image-caption>图形化页面</figcaption></figure></p><p>从上图我们可以发现 Mouse 类的 Steal 方法占用了大量的内存。我们点击 VIEW -> Source 可以看到具体代码文件、行数以及资源使用情况。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.6wqhp62eth.webp title=代码细节 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.6wqhp62eth.webp data-sub-html="<h2> </h2><p>代码细节</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.6wqhp62eth.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.6wqhp62eth.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.6wqhp62eth.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.6wqhp62eth.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.6wqhp62eth.webp></a><figcaption class=image-caption>代码细节</figcaption></figure></p><p>注释掉相关代码，重新编译运行，再次查看资源消耗的情况，可以发现 CPU 和内存都占用较低了。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1e8d90y1c7.webp title=CPU和内存占用情况下降 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1e8d90y1c7.webp data-sub-html="<h2> </h2><p>CPU和内存占用情况下降</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1e8d90y1c7.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1e8d90y1c7.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1e8d90y1c7.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1e8d90y1c7.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1e8d90y1c7.webp></a><figcaption class=image-caption>CPU和内存占用情况下降</figcaption></figure></p><p>其中在 web 页面上，SIMPLE 里有四个选项，他们的含义为：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>alloc_objects</td><td>程序累计申请的对象数</td></tr><tr><td>alloc_space</td><td>程序累计申请的内存大小</td></tr><tr><td>inuse_objects</td><td>程序当前持有的对象数</td></tr><tr><td>inuse_space</td><td>程序当前占用的内存大小</td></tr></tbody></table><p>在堆内存采样中，默认展示的是 inuse_space 视图，只展示当前持有的内存，但如果有内存已经释放，这是 inuse 采样就不会展示了。</p><p>在后续排查 GC 问题的时候，也可以根据 alloc_space 指标来排查。</p><h2 id=排查频繁内存回收>排查频繁内存回收</h2><p>你应该知道，频繁的 GC 对 golang 程序性能的影响也是非常严重的。虽然现在这个炸弹程序内存使用量并不高，但这会不会是频繁 GC 之后的假象呢？</p><p>为了获取程序运行过程中 GC 日志，我们需要先退出炸弹程序，再在重新启动前赋予一个环境变量，同时为了避免其他日志的干扰，使用 grep 筛选出 GC 日志查看：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>GODEBUG</span><span class=o>=</span><span class=nv>gctrace</span><span class=o>=</span><span class=m>1</span> ./pprof-amd64-linux <span class=p>|</span> grep gc
</span></span></code></pre></td></tr></table></div></div><p>可以发现打出的 log 信息，分析可以发现，GC 差不多每 3 秒就发生一次，且每次 GC 都会从 16MB 清理到几乎 0MB，说明程序在不断的申请内存再释放，这是高性能 golang 程序所不允许的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gc 1 @0.001s 1%: 0.005+0.64+0.001 ms clock, 0.005+0.032/0.19/0+0.001 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 2 @1.007s 0%: 0.021+0.36+0.002 ms clock, 0.021+0.038/0.094/0.065+0.002 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 3 @2.009s 0%: 0.031+0.49+0.001 ms clock, 0.031+0.088/0.10/0+0.001 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 4 @3.013s 0%: 0.030+0.38+0.002 ms clock, 0.030+0.040/0.11/0.034+0.002 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 5 @4.017s 0%: 0.033+0.40+0.002 ms clock, 0.033+0.088/0.10/0+0.002 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 6 @5.021s 0%: 0.031+0.34+0.002 ms clock, 0.031+0.089/0.10/0+0.002 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 7 @6.026s 0%: 0.43+0.35+0.002 ms clock, 0.43+0.088/0.10/0+0.002 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 8 @7.031s 0%: 0.031+0.42+0.002 ms clock, 0.031+0.10/0.10/0+0.002 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 9 @8.034s 0%: 0.030+0.40+0.002 ms clock, 0.030+0.095/0.11/0+0.002 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 10 @9.038s 0%: 0.030+0.40+0.002 ms clock, 0.030+0.049/0.14/0.008+0.002 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 11 @10.042s 0%: 0.037+0.41+0.001 ms clock, 0.037+0.058/0.15/0.001+0.001 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 12 @11.045s 0%: 0.033+0.47+0.001 ms clock, 0.033+0.044/0.14/0.009+0.001 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 13 @12.049s 0%: 0.033+0.52+0.002 ms clock, 0.033+0.054/0.15/0+0.002 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 14 @13.052s 0%: 0.032+0.37+0.002 ms clock, 0.032+0.048/0.11/0.038+0.002 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 15 @14.054s 0%: 0.032+0.41+0.001 ms clock, 0.032+0.046/0.13/0.034+0.001 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span><span class=line><span class=cl>gc 16 @15.057s 0%: 0.032+0.48+0.002 ms clock, 0.032+0.045/0.15/0+0.002 ms cpu, 16-&gt;16-&gt;0 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 1 P
</span></span></code></pre></td></tr></table></div></div><p>此外也可以通过 heap 的 alloc_space 视图来查看。执行命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go tool pprof -http<span class=o>=</span>:8080 <span class=s2>&#34;http://localhost:6060/debug/pprof/heap&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>选择 SIMPLE->alloc_space，发现 Dog 方法申请了大量的内存。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpvp2w8.webp title=Dog类申请了784MB的内存 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpvp2w8.webp data-sub-html="<h2> </h2><p>Dog类申请了784MB的内存</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpvp2w8.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpvp2w8.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpvp2w8.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpvp2w8.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpvp2w8.webp></a><figcaption class=image-caption>Dog类申请了784MB的内存</figcaption></figure></p><p>查看源码分析代码的问题，原来是 Run 方法在不断的申请内存。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.wibkkytal.webp title=Dog类申请内存代码细节 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.wibkkytal.webp data-sub-html="<h2> </h2><p>Dog类申请内存代码细节</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.wibkkytal.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.wibkkytal.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.wibkkytal.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.wibkkytal.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.wibkkytal.webp></a><figcaption class=image-caption>Dog类申请内存代码细节</figcaption></figure></p><p>这里有个小插曲，你可尝试一下将 <code>16 * constant.Mi</code> 修改成一个较小的值，重新编译运行，会发现并不会引起频繁 GC，原因是在 golang 里，对象是使用堆内存还是栈内存，由编译器进行逃逸分析并决定，如果对象不会逃逸，便可在使用栈内存，但总有意外，就是对象的尺寸过大时，便不得不使用堆内存。所以这里设置申请 16 MiB 的内存就是为了避免编译器直接在栈上分配，如果那样得话就不会涉及到 GC 了。</p><p>我们同样注释掉问题代码，重新编译执行，可以看到这一次，程序的 GC 频度要低很多，以至于短时间内都看不到 GC 日志了：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumi71wh.webp title=执行GC追踪，发现GC不频繁了 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumi71wh.webp data-sub-html="<h2> </h2><p>执行GC追踪，发现GC不频繁了</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumi71wh.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumi71wh.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumi71wh.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumi71wh.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumi71wh.webp></a><figcaption class=image-caption>执行GC追踪，发现GC不频繁了</figcaption></figure></p><h2 id=排查协程泄漏问题>排查协程泄漏问题</h2><p>在<a href=http://localhost:6060/debug/pprof/ target=_blank rel="noopener noreffer">http://localhost:6060/debug/pprof/</a>页面可以发现，协程的数量居然多达 100 多个，这对这个小程序来说，是不正常的，通过运行下列命令，去查看到底是怎么回事</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go tool pprof -http<span class=o>=</span>:8080 <span class=s2>&#34;http://localhost:6060/debug/pprof/goroutine&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>得到图形化页面，如下图所示：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpq17yt.webp title=协程pprof页面 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpq17yt.webp data-sub-html="<h2> </h2><p>协程pprof页面</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpq17yt.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpq17yt.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpq17yt.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpq17yt.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.5c0qpq17yt.webp></a><figcaption class=image-caption>协程pprof页面</figcaption></figure></p><p>发现调用的链路比较长，此时我们可以通过火焰图来更直观的查看，点击 VIEW->Flame Graph，我们可以发现是 <code>Wolf.Drink()</code> 这个函数产生了大量的协程。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.45g2q8lf2.webp title=pprof生成的火焰图 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.45g2q8lf2.webp data-sub-html="<h2> </h2><p>pprof生成的火焰图</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.45g2q8lf2.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.45g2q8lf2.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.45g2q8lf2.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.45g2q8lf2.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.45g2q8lf2.webp></a><figcaption class=image-caption>pprof生成的火焰图</figcaption></figure></p><p>在 VIEW->Source 里，输入 <code>Drink</code> 来查询代码细节，可以看到，<code>Drink</code> 方法每次会起 10 个协程，每个协程会 sleep 30 秒再推出，而 <code>Drink</code> 函数又被反复的调用，这才导致了大量的协程泄漏。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1755dm4xgl.webp title=Wolf类Drink方法代码细节 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1755dm4xgl.webp data-sub-html="<h2> </h2><p>Wolf类Drink方法代码细节</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1755dm4xgl.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1755dm4xgl.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1755dm4xgl.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1755dm4xgl.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.1755dm4xgl.webp></a><figcaption class=image-caption>Wolf类Drink方法代码细节</figcaption></figure></p><p>试想一下，如果我们业务中起的协程会永久阻塞，那么泄漏的协程数量便会持续增加，从而导致内存的持续增加，那么迟早会被 OS Kill 掉。我们通过注释掉问题代码，重新运行可以看到协程数量已经降低到个位数的水平了。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7i05bhqi0a.webp title=goroutine数量减少 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7i05bhqi0a.webp data-sub-html="<h2> </h2><p>goroutine数量减少</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7i05bhqi0a.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7i05bhqi0a.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7i05bhqi0a.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7i05bhqi0a.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7i05bhqi0a.webp></a><figcaption class=image-caption>goroutine数量减少</figcaption></figure></p><h2 id=排查锁的争用关系>排查锁的争用关系</h2><p>到目前为止，我们已经基本解决了这个炸弹程序所有的资源占用问题，但是日常业务中不仅仅有资源占用问题，还有性能问题。</p><p>下面将开始对性能进行优化，首先能想到的就是<strong>不合理的锁竞争</strong>，比如加锁时间过长。发现 debug 页面里存在锁的竞争情况。执行下列命令进行查看。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go tool pprof -http<span class=o>=</span>:8080 <span class=s2>&#34;http://localhost:6060/debug/pprof/mutex&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>可以发现 Wolf 这个类里，存在锁长时间等待问题。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8ojgk6j1z9.webp title=Wolf锁竞争图形化页面 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8ojgk6j1z9.webp data-sub-html="<h2> </h2><p>Wolf锁竞争图形化页面</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8ojgk6j1z9.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8ojgk6j1z9.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8ojgk6j1z9.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8ojgk6j1z9.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8ojgk6j1z9.webp></a><figcaption class=image-caption>Wolf锁竞争图形化页面</figcaption></figure></p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbifmksu.webp title=锁竞争具体代码细节 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbifmksu.webp data-sub-html="<h2> </h2><p>锁竞争具体代码细节</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbifmksu.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbifmksu.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbifmksu.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbifmksu.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbifmksu.webp></a><figcaption class=image-caption>锁竞争具体代码细节</figcaption></figure></p><p>可以看到，这个锁由主协程 Lock，并启动子协程去 Unlock，主协程会阻塞在第二次 Lock 这里等待子协程完成任务，但由于子协程足足睡眠了一秒，导致主协程等待这个锁释放足足等了一秒钟。我们对此处代码进行修改即可修复问题。</p><h2 id=排查协程阻塞问题>排查协程阻塞问题</h2><p>除了锁会阻塞之外，还有很多逻辑会导致当前协程阻塞。可以发现 debug 页面上，存在两个 block。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.32hq6btj2v.webp title=/debug/pprof页面 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.32hq6btj2v.webp data-sub-html="<h2> </h2><p>/debug/pprof页面</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.32hq6btj2v.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.32hq6btj2v.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.32hq6btj2v.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.32hq6btj2v.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.32hq6btj2v.webp></a><figcaption class=image-caption>/debug/pprof页面</figcaption></figure></p><p>执行命令查看 block 信息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go tool pprof -http<span class=o>=</span>:8080 <span class=s2>&#34;http://localhost:6060/debug/pprof/block&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>可以发现存在 Cat 类的方法导致存在协程阻塞。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.60u09u57fh.webp title=Cat阻塞 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.60u09u57fh.webp data-sub-html="<h2> </h2><p>Cat阻塞</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.60u09u57fh.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.60u09u57fh.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.60u09u57fh.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.60u09u57fh.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.60u09u57fh.webp></a><figcaption class=image-caption>Cat阻塞</figcaption></figure></p><p>查询 Cat 涉及到的源码</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7zq706cfoc.webp title=Cat代码细节 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7zq706cfoc.webp data-sub-html="<h2> </h2><p>Cat代码细节</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7zq706cfoc.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7zq706cfoc.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7zq706cfoc.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7zq706cfoc.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7zq706cfoc.webp></a><figcaption class=image-caption>Cat代码细节</figcaption></figure></p><p>可以看到这里不同于直接 sleep 一秒，这里是从一个 channel 里读数据时，发生了阻塞。直到这个 channel 在一秒后才有数据读出，因此这里会导致程序阻塞，而不是睡眠。</p><p>我们对此代码注释掉，重新编译运行后发现程序还有一个 block。通过排查分析后我们发现是因为程序提供了 HTTP 的 pprof 服务，程序阻塞在对 HTTP 端口的监听上，因此这个阻塞是正常的。</p><h2 id=排查内存泄漏>排查内存泄漏</h2><p>pprof 中有一个 -base 选项，它用于指定基准采样文件，这样可以通过比较两个采样数据，从而查看到指标的变化，例如函数的 CPU 使用时间或内存分配情况。</p><p>举个具体的例子，在业务中有一个低频调用的接口存在内存泄漏（OOM），它每被调用一就会泄漏 1MiB 的内存。这个接口每天被调用 10 次。假设我们给这个服务分配了 100MiB 空余的内存，也就是说这个接口基本上每十天就会挂一次，但当我们排查问题的时候，会发现内存是缓慢增长的。此时如果你仅通过 pprof 采样单个文件来观察，基本上很难会发现泄漏点。</p><p>这时候 base 选项就派上用场了，我们可以在服务启动后采集一个基准样本，过几天后再采集一次。通过比对这两个样本增量数据，我们就很容易发现出泄漏点。</p><p>同样的，这个炸弹我也已经预埋了这样一个缓慢的泄漏点，但时间我缩短了一下。相信在上面的实操过程中你也发现了端倪，下面我们开始实操一下。</p><p>我们运行这个炸弹程序，将启动时的堆内存分配情况保存下来，你可以在 debug 页面点击下载，也可以在终端中执行 <code>curl -o heap-base http://localhost:6060/debug/pprof/heap</code> 来下载。</p><p>在资源管理器中我们可以看到程序刚启动的时候，内存占用并不高：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumidy30.webp title="<code>top</code>命令里进程消耗资源情况" data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumidy30.webp data-sub-html="<h2> </h2><p><code>top</code>命令里进程消耗资源情况</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumidy30.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumidy30.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumidy30.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumidy30.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.8kzumidy30.webp></a><figcaption class=image-caption><code>top</code>命令里进程消耗资源情况</figcaption></figure></p><p>过了一段时间之后，我们可以清楚的发现程序内存开始逐渐增长：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbih4chx.webp title=一段时间后进程资源消耗情况 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbih4chx.webp data-sub-html="<h2> </h2><p>一段时间后进程资源消耗情况</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbih4chx.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbih4chx.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbih4chx.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbih4chx.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.77dbih4chx.webp></a><figcaption class=image-caption>一段时间后进程资源消耗情况</figcaption></figure></p><p>此时我们再执行 <code>curl -o heap-target http://localhost:6060/debug/pprof/heap</code> 获取到当前的采样数据。</p><p>再获取到两个样本数据后，我们通过 base 选项将 heap-base 作为基准，查看运行的这段时间内哪里内存增长了</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go tool pprof -http<span class=o>=</span>:8080 -base heap-base heap-target
</span></span></code></pre></td></tr></table></div></div><p>可以发现在这段时间内，<code>Mouse.Pee()</code>方法增长了 768MB 的内存，显然这里发生了内存泄漏。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.sypmvql1f.webp title=Mouse内存泄漏 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.sypmvql1f.webp data-sub-html="<h2> </h2><p>Mouse内存泄漏</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.sypmvql1f.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.sypmvql1f.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.sypmvql1f.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.sypmvql1f.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.sypmvql1f.webp></a><figcaption class=image-caption>Mouse内存泄漏</figcaption></figure></p><p>通过查看源码，修复问题。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4qr33k3rck.webp title=Mouse代码细节 data-thumbnail=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4qr33k3rck.webp data-sub-html="<h2> </h2><p>Mouse代码细节</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4qr33k3rck.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4qr33k3rck.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4qr33k3rck.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4qr33k3rck.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.4qr33k3rck.webp></a><figcaption class=image-caption>Mouse代码细节</figcaption></figure></p><h2 id=总结>总结</h2><p>本文主要内容为 pprof 工具的使用，介绍了通过命令行、可视化等方式进行排查。虽然例子比较简单，但是相信通过这些简单的例子可以让你不在畏惧 pprof。</p><h2 id=reference>Reference</h2><ul><li><a href=https://blog.wolfogre.com/posts/go-ppof-practice/ target=_blank rel="noopener noreffer">golang pprof 实战</a></li><li><a href=https://farmerchillax.github.io/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/# target=_blank rel="noopener noreffer">Go 性能分析工具</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2024-07-07&nbsp;<a class=git-hash href=https://github.com/pjimming/blog/commit/02e978f0a52e89cc5f9af7fab75dce874e75226e target=_blank title="commit by panjiangming(panjiangming@kuaishou.com) 02e978f0a52e89cc5f9af7fab75dce874e75226e: update cdn">
<i class="fas fa-hashtag fa-fw" aria-hidden=true></i>02e978f</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/2024-03-24/pprof/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://blog.pjmcode.top/2024-03-24/pprof/ data-title=Golang性能分析工具之pprof实战 data-hashtags=golang,pprof,性能优化,实战><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://blog.pjmcode.top/2024-03-24/pprof/ data-hashtag=golang><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://blog.pjmcode.top/2024-03-24/pprof/ data-title=Golang性能分析工具之pprof实战><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://blog.pjmcode.top/2024-03-24/pprof/ data-title=Golang性能分析工具之pprof实战><i data-svg-src=/lib/simple-icons/icons/line.min.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://blog.pjmcode.top/2024-03-24/pprof/ data-title=Golang性能分析工具之pprof实战 data-image=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/20240324/image-image.7smz4kuu12.webp><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/golang/>Golang</a>,&nbsp;<a href=/tags/pprof/>Pprof</a>,&nbsp;<a href=/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>性能优化</a>,&nbsp;<a href=/tags/%E5%AE%9E%E6%88%98/>实战</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2024-03-21/instantid/ class=prev rel=prev title="【论文泛读】InstantID: Zero-shot Identity-Preserving Generation in Seconds"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>【论文泛读】InstantID: Zero-shot Identity-Preserving Generation in Seconds</a>
<a href=/2024-03-24/pprof-theory/ class=next rel=next title=Golang性能分析工具之pprof采样过程与原理>Golang性能分析工具之pprof采样过程与原理<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app>Giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><span id=run-time></span></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2024 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=备案编号" target=_blank>浙ICP备2024074882号</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/plugins/zoom/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{giscus:{category:"Announcements",categoryId:"DIC_kwDOLZmgDc4Cdm7x",darkTheme:"preferred_color_scheme",emitMetadata:"0",inputPosition:"top",lang:"zh-CN",lazyLoading:!1,lightTheme:"light",mapping:"pathname",reactionsEnabled:"1",repo:"pjimming/blog-comment",repoId:"R_kgDOLZmgDQ"}},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript src=https://cdn.staticfile.net/jquery/2.2.4/jquery.min.js></script><script type=text/javascript src=/js/custom.js></script></body></html>