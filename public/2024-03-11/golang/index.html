<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>面试题精选--Golang篇 - 江明说|Jimmy Talk</title><meta name=Description content="江明说"><meta property="og:url" content="https://blog.pjmcode.top/2024-03-11/golang/">
<meta property="og:site_name" content="江明说|Jimmy Talk"><meta property="og:title" content="面试题精选--Golang篇"><meta property="og:description" content="总结一些常考的 Golang 面试题，相关资料皆从网络上收集"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-11T00:24:54+08:00"><meta property="article:modified_time" content="2024-07-07T10:07:16+08:00"><meta property="article:tag" content="Interview"><meta property="article:tag" content="Golang"><meta property="og:image" content="https://blog.pjmcode.top/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.pjmcode.top/logo.png"><meta name=twitter:title content="面试题精选--Golang篇"><meta name=twitter:description content="总结一些常考的 Golang 面试题，相关资料皆从网络上收集"><meta name=application-name content="江明说"><meta name=apple-mobile-web-app-title content="江明说"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=/images/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.pjmcode.top/2024-03-11/golang/><link rel=prev href=https://blog.pjmcode.top/2024-03-09/build-0/><link rel=next href=https://blog.pjmcode.top/2024-03-11/mysql/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"面试题精选--Golang篇","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.pjmcode.top\/2024-03-11\/golang\/"},"genre":"posts","keywords":"interview, golang","wordcount":5192,"url":"https:\/\/blog.pjmcode.top\/2024-03-11\/golang\/","datePublished":"2024-03-11T00:24:54+08:00","dateModified":"2024-07-07T10:07:16+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"PanJM"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="江明说|Jimmy Talk"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/favicon.ico data-srcset="/images/favicon.ico, /images/favicon.ico 1.5x, /images/favicon.ico 2x" data-sizes=auto alt=/images/favicon.ico title=/images/favicon.ico>Jimmy Talk</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class='fa-solid fa-box-archive'></i> 所有文章 </a><a class=menu-item href=/tags/><i class='fa-solid fa-tag'></i> 标签 </a><a class=menu-item href=/categories/><i class='fa-solid fa-table-list'></i> 分类 </a><a class=menu-item href=/friend/><i class='fa-solid fa-user-group'></i> 友链 </a><a class=menu-item href=/book-list/><i class='fa-solid fa-book'></i> 书单 </a><a class=menu-item href=/about/><i class='fa-regular fa-address-card'></i> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="江明说|Jimmy Talk"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/favicon.ico data-srcset="/images/favicon.ico, /images/favicon.ico 1.5x, /images/favicon.ico 2x" data-sizes=auto alt=/images/favicon.ico title=/images/favicon.ico>Jimmy Talk</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title><i class='fa-solid fa-box-archive'></i>所有文章</a><a class=menu-item href=/tags/ title><i class='fa-solid fa-tag'></i>标签</a><a class=menu-item href=/categories/ title><i class='fa-solid fa-table-list'></i>分类</a><a class=menu-item href=/friend/ title><i class='fa-solid fa-user-group'></i>友链</a><a class=menu-item href=/book-list/ title><i class='fa-solid fa-book'></i>书单</a><a class=menu-item href=/about/ title><i class='fa-regular fa-address-card'></i>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">面试题精选--Golang篇</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/pjimming/ title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>PanJM</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/interview/><i class="far fa-folder fa-fw" aria-hidden=true></i>Interview</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2024-03-11>2024-03-11</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 5192 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 11 分钟&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.9nzjdzppc1.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.9nzjdzppc1.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.9nzjdzppc1.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.9nzjdzppc1.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.9nzjdzppc1.webp title=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.9nzjdzppc1.webp></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#切片---slice>切片 - Slice</a><ul><li><a href=#同一-slice-上的切片其底层数组是同一个吗>同一 slice 上的切片其底层数组是同一个吗</a></li><li><a href=#append-操作返回的底层数组会变吗>append 操作返回的底层数组会变吗</a></li><li><a href=#如果对-slice-中的元素取指针放到一个新的数组中新数组中的值是什么样的>如果对 slice 中的元素取指针，放到一个新的数组中，新数组中的值是什么样的</a></li></ul></li><li><a href=#映射---map>映射 - Map</a><ul><li><a href=#map-是并发安全的吗>Map 是并发安全的吗</a></li></ul></li><li><a href=#通道---channel>通道 - Channel</a><ul><li><a href=#有缓冲与无缓冲的-channel-之间的区别>有缓冲与无缓冲的 Channel 之间的区别</a></li></ul></li><li><a href=#上下文---context>上下文 - Context</a><ul><li><a href=#什么是-context>什么是 Context</a></li></ul></li><li><a href=#并发模型---goroutine-与-gmp>并发模型 - Goroutine 与 GMP</a><ul><li><a href=#什么是协程泄漏>什么是协程泄漏</a></li><li><a href=#什么是-gmp-模型>什么是 GMP 模型</a></li><li><a href=#m-和-p-是一对一的吗>M 和 P 是一对一的吗</a></li><li><a href=#处理器-p-如何管理多个线程-m>处理器 P 如何管理多个线程 M</a></li><li><a href=#死循环的协程如何调度>死循环的协程如何调度</a></li><li><a href=#阻塞的协程如何调度>阻塞的协程如何调度</a></li></ul></li><li><a href=#垃圾回收---gc>垃圾回收 - GC</a><ul><li><a href=#go-中的垃圾回收是怎样的>Go 中的垃圾回收是怎样的</a></li><li><a href=#三色标记的过程>三色标记的过程</a></li></ul></li><li><a href=#其他>其他</a><ul><li><a href=#go-中的-make-和-new-的区别>Go 中的 make 和 new 的区别</a></li><li><a href=#在-defer-中修改了局部变量并-return返回值为类型和变量类型两种情况下会返回什么>在 defer 中修改了局部变量并 return，返回值为类型和(变量+类型)两种情况下会返回什么</a></li></ul></li></ul></nav></div></div><div class=content id=content><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fwnote"></i>注意<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><span>这篇文章最后修改于</span>
<span class=timeago datetime=2024-07-07T10:07:16 title="July 7, 2024">July 7, 2024</span>
<span>，请鉴别其时效性，以免造成不必要的麻烦。</span></div></div></div><p>总结一些常考的 Golang 面试题，相关资料皆从网络上收集</p><hr><h2 id=切片---slice>切片 - Slice</h2><h3 id=同一-slice-上的切片其底层数组是同一个吗>同一 slice 上的切片其底层数组是同一个吗</h3><p>同一切片上的切片共享相同的底层数组。在 Go 中，切片是对数组的一个引用，而不是值的拷贝。当你对一个切片进行切片操作时，产生的新切片将仍然引用相同的底层数组，而不会创建新的底层数组。这意味着，无论你如何对切片进行切割或修改，底层数组都会相应地被修改。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// PASS
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>TestSlice1</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>s1</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>[:]</span>
</span></span><span class=line><span class=cl>	<span class=nx>s2</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>s</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=p>=</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>99</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>assert</span><span class=p>.</span><span class=nf>True</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>s1</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>assert</span><span class=p>.</span><span class=nf>True</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>s1</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>==</span> <span class=mi>99</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>assert</span><span class=p>.</span><span class=nf>True</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>s2</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=mi>99</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=append-操作返回的底层数组会变吗>append 操作返回的底层数组会变吗</h3><p>在使用 append 函数向切片中添加元素时，如果当前切片容量不足以容纳新元素，append 函数会分配一个新的底层数组，将原切片中的元素复制到新的数组中，并在新的数组中添加新元素。这意味着 append 操作可能会返回一个指向不同底层数组的新切片。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// PASS
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>TestSlice2</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>s2</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s1</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>s1</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>100</span>
</span></span><span class=line><span class=cl>	<span class=nx>assert</span><span class=p>.</span><span class=nf>True</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>s1</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>s2</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>当切片容量足够时，append 函数会原地修改原切片，因此返回的切片仍然指向相同的底层数组。在这种情况下，原切片可能会被修改，但它仍然引用相同的底层数组。</p><h3 id=如果对-slice-中的元素取指针放到一个新的数组中新数组中的值是什么样的>如果对 slice 中的元素取指针，放到一个新的数组中，新数组中的值是什么样的</h3><p>考察对 <code>for...range...</code> 的了解。</p><p>对于<code>for _, v := range array</code>，每次都会对 <code>v</code> 进行赋值，所以最后取到的都是变量 <code>v</code> 的地址。</p><p>可通过下列两种方式获得所有元素的地址：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 方法一：局部变量拷贝v，也可以用其他变量名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>v</span> <span class=o>:=</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl>    <span class=nx>pointers</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>v</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 方法二：直接通过下标获取
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>pointers</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=映射---map>映射 - Map</h2><h3 id=map-是并发安全的吗>Map 是并发安全的吗</h3><p>不是，Map 不并发安全，如果同时写同一个 Map，会造成 panic</p><h2 id=通道---channel>通道 - Channel</h2><h3 id=有缓冲与无缓冲的-channel-之间的区别>有缓冲与无缓冲的 Channel 之间的区别</h3><p>主要体现在两个方面：阻塞行为和并发性能。</p><ol><li><p><strong>缓冲 channel：</strong></p><ul><li>缓冲 channel 允许在发送数据时，如果 channel 中还有可用的缓冲区，则发送操作不会被阻塞，直接将数据发送到缓冲区中。</li><li>在接收数据时，如果 channel 中有数据可用，则接收操作不会被阻塞，直接从缓冲区中读取数据。</li><li>当 channel 中的缓冲区满了时，发送操作会阻塞直到有其他 goroutine 从 channel 中接收数据，腾出缓冲区空间。</li><li>同样地，当 channel 中的缓冲区为空时，接收操作会阻塞直到有其他 goroutine 向 channel 中发送数据。</li></ul></li><li><p><strong>无缓冲 channel：</strong></p><ul><li>无缓冲 channel 发送数据时，发送操作会阻塞直到有其他 goroutine 准备好接收数据。</li><li>接收数据时，接收操作会阻塞直到有其他 goroutine 发送数据到 channel 中。</li><li>无缓冲 channel 的发送和接收操作是同步的，它们会导致发送和接收两个 goroutine 同时被阻塞，直到它们能够匹配到对应的操作。</li><li>无缓冲 channel 通常用于同步 goroutine 之间的通信，保证数据的可靠传输和同步。</li></ul></li></ol><h2 id=上下文---context>上下文 - Context</h2><h3 id=什么是-context>什么是 Context</h3><p>在 Go 语言中，<code>context.Context</code> 是一个用于在 Goroutine 之间传递请求相关值、取消信号和截止时间的标准方式。它主要用于控制 Goroutine 的生命周期，以及在并发环境下进行请求处理、超时控制和取消操作等。</p><p><code>context.Context</code> 的核心方法包括：</p><ol><li><p><strong><code>context.Background()</code></strong>：返回一个空的 <code>Context</code>，用作父 <code>Context</code>，通常在整个请求的生命周期中作为顶级的 <code>Context</code> 使用。</p></li><li><p><strong><code>context.WithCancel(parent)</code></strong>：返回一个带有取消信号的 <code>Context</code> 和一个取消函数。当调用取消函数时，该 <code>Context</code> 及其所有子 <code>Context</code> 都会收到取消信号。</p></li><li><p><strong><code>context.WithDeadline(parent, deadline)</code></strong>：返回一个带有截止时间的 <code>Context</code>。当到达截止时间时，该 <code>Context</code> 及其所有子 <code>Context</code> 都会收到取消信号。</p></li><li><p><strong><code>context.WithTimeout(parent, timeout)</code></strong>：返回一个带有超时时间的 <code>Context</code>。当超过指定的超时时间时，该 <code>Context</code> 及其所有子 <code>Context</code> 都会收到取消信号。</p></li><li><p><strong><code>context.WithValue(parent, key, value)</code></strong>：返回一个带有请求相关值的 <code>Context</code>。这些值可以在 Goroutine 之间传递，但不应该用于传递可选参数。</p></li></ol><p><code>Context</code> 的值应该是请求范围内的元数据，例如请求 ID、用户身份验证信息等。不应该用于传递可选参数，而应该通过函数参数传递。</p><p><code>context.Context</code> 的主要用途包括：</p><ul><li><strong>取消信号传递</strong>：用于在 Goroutine 中传递取消信号，以便在需要时取消处理。</li><li><strong>超时控制</strong>：用于在一定时间内进行请求处理，并在超时时取消处理。</li><li><strong>请求范围值传递</strong>：用于在 Goroutine 之间传递请求相关值，例如请求 ID、用户身份验证信息等。</li></ul><p>使用 <code>context.Context</code> 可以有效地控制 Goroutine 的生命周期，避免资源泄漏和 Goroutine 泄漏，并实现更健壮的并发程序。</p><h2 id=并发模型---goroutine-与-gmp>并发模型 - Goroutine 与 GMP</h2><h3 id=什么是协程泄漏>什么是协程泄漏</h3><p>协程泄露是指在使用协程时，由于某些原因导致协程无法被及时回收和释放，从而占用了系统资源而无法被重复利用的情况。协程泄露可能会导致内存泄露或者系统资源耗尽等问题，影响程序的性能和稳定性。</p><p>常见引起协程泄露的原因包括：</p><ol><li><p><strong>未关闭通道（Channel）：</strong> 当一个协程向通道发送数据后，如果没有其他协程接收数据，通道将会一直阻塞，导致该协程无法退出，从而产生协程泄露。因此，在使用通道时需要确保及时关闭通道以释放协程。</p></li><li><p><strong>循环引用：</strong> 如果协程持有某些资源，而这些资源又持有了对协程的引用，形成了循环引用，那么即使协程不再需要这些资源，也无法被回收，从而导致协程泄露。这种情况下，需要仔细检查资源的生命周期，确保适时释放资源。</p></li><li><p><strong>阻塞操作：</strong> 协程在执行过程中可能会发生阻塞，例如等待 I/O 操作完成或者等待锁释放等，如果阻塞时间过长或者无法及时结束，可能会导致协程泄露。需要谨慎设计协程的执行逻辑，避免长时间的阻塞操作。</p></li><li><p><strong>未处理异常：</strong> 如果协程发生了未捕获的异常，并且没有恢复或处理这些异常，那么协程可能会被永久性地终止而无法被回收，从而导致泄露。</p></li></ol><h3 id=什么是-gmp-模型>什么是 GMP 模型</h3><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.2dog450tyj.webp data-srcset="https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.2dog450tyj.webp, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.2dog450tyj.webp 1.5x, https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.2dog450tyj.webp 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.2dog450tyj.webp title=image.2dog450tyj.webp></p><ul><li>Goroutine（Go 协程）： Goroutine 是 Go 语言中的轻量级线程，它由 Go 运行时（runtime）调度和管理。Goroutine 可以看作是执行并发任务的独立单位，相较于传统的线程，Goroutine 的创建和切换成本非常低，因此可以高效地支持大量的并发任务。</li><li>M（线程）： M 代表着操作系统的线程（machine thread）。每个 M 都会关联一个线程，它负责执行 Goroutine。M 的数量是由 Go 运行时动态管理的，它会根据系统的核心数量等因素动态调整 M 的数量，以充分利用系统资源。</li><li>P（处理器）： P 是一种逻辑处理器，它负责调度和管理 Goroutine。P 的数量通常是固定的，并且与 CPU 核心数有关。P 会将 Goroutine 分配给 M，并负责调度 M 在 CPU 上执行。P 的数量可以通过 Go 语言的 GOMAXPROCS 环境变量来控制。</li></ul><h3 id=m-和-p-是一对一的吗>M 和 P 是一对一的吗</h3><p>M 和 P 是多对多的关系，一个 P 可以管理多个 M，但一个 M 同一时间只能被一个 P 所关联。</p><h3 id=处理器-p-如何管理多个线程-m>处理器 P 如何管理多个线程 M</h3><ul><li>本地队列（Local Queue）： 每个 P 都有一个本地队列，用于存储被当前 P 管理的 Goroutine。这个队列是针对当前 P 而言的，因此可以高效地进行操作，比如入队和出队。本地队列可以减少锁的竞争，提高并发性能。</li><li>全局队列（Global Queue）： 所有 P 共享一个全局队列，用于存储没有被任何 P 管理的 Goroutine。当一个 P 的本地队列空了，它可以从全局队列中获取 Goroutine 来执行。全局队列通常会使用锁进行保护，因为多个 P 可能同时竞争全局队列中的 Goroutine。</li><li>空闲 M 列表（Idle M List）： P 还会维护一个空闲 M 的列表。当 P 的本地队列满了或者被阻塞时，它可以从空闲 M 列表中获取一个空闲的 M 来执行 Goroutine。</li></ul><p>P 通过这些队列来动态管理多个 M 的调度和执行，从而实现高效的并发调度。当一个 M 执行完成或者阻塞时，它会回到 P 的管理下，然后再次被分配 Goroutine 执行。</p><h3 id=死循环的协程如何调度>死循环的协程如何调度</h3><ul><li>Preemption（抢占）： Go 语言的运行时系统会在一定的时间间隔内（通常几毫秒）进行抢占调度，即使一个协程正在执行一个死循环，也会在一定的时间后将处理器让给其他协程执行。这种机制能够保证其他协程不会因为某个协程的死循环而无法执行。</li><li>系统调用或阻塞操作： 如果一个协程在执行死循环时发起了系统调用或者进行了阻塞操作（如等待 IO 完成），那么它会被 Go 运行时系统暂时挂起，直到系统调用完成或阻塞操作解除，从而让其他协程有机会执行。</li><li>手动控制： 在一些特殊情况下，可以手动控制死循环协程的执行。例如，可以使用 Go 语言的 select{} 语句结合 time.After 通道来设置一个超时，以便让死循环协程周期性地让出处理器，从而允许其他协程执行。但这种方法需要手动在死循环中加入超时检查的逻辑。</li></ul><h3 id=阻塞的协程如何调度>阻塞的协程如何调度</h3><ul><li>系统调用阻塞： 当一个协程执行系统调用（如文件读取、网络请求等）而导致阻塞时，Go 调度器会将该协程暂停，并尝试调度其他可运行的协程来继续执行。当系统调用完成后，阻塞的协程会重新被调度执行。</li><li>通道阻塞： 当一个协程试图发送或接收数据到或从一个无缓冲通道时，如果通道中没有对应的接收方或发送方，该协程会被阻塞。在这种情况下，Go 调度器会暂停被阻塞的协程，并尝试调度其他可运行的协程执行，直到通道操作可以完成。</li><li>等待组（WaitGroup）阻塞： 当主协程等待一组其他协程完成时，通常会使用 <code>sync.WaitGroup</code> 进行同步。在这种情况下，主协程会调用 <code>WaitGroup.Wait()</code> 方法阻塞等待，直到所有其他协程完成并调用 <code>WaitGroup.Done()</code> 通知完成。Go 调度器会在这种情况下暂停主协程，并继续执行其他可运行的协程。</li></ul><h2 id=垃圾回收---gc>垃圾回收 - GC</h2><h3 id=go-中的垃圾回收是怎样的>Go 中的垃圾回收是怎样的</h3><p>Go 语言的垃圾回收（Garbage Collection，GC）是一种自动管理内存的机制，它负责在程序运行时自动识别并释放不再使用的内存对象，以避免内存泄漏和提高内存利用率。</p><p>以下是 Go 语言的垃圾回收的一些特点和工作原理：</p><ol><li><p><strong>并发标记清除：</strong> Go 语言的垃圾回收器采用了并发标记清除（Concurrent Mark and Sweep）算法。在标记阶段，垃圾回收器会从根对象开始，遍历程序中的对象图，并标记出所有可达的对象。在清除阶段，垃圾回收器会扫描堆中的对象，清除所有未被标记的对象。这个过程是并发执行的，不会阻塞用户程序的执行。</p></li><li><p><strong>三色标记法：</strong> Go 语言的垃圾回收器使用了三色标记法，将对象分为三种状态：白色、灰色和黑色。白色表示对象未被访问，灰色表示对象被标记但其子对象还未被标记，黑色表示对象及其子对象已被标记。在标记阶段，垃圾回收器通过遍历对象图，将对象从白色变为灰色，并将其子对象加入标记队列。在清除阶段，垃圾回收器清除所有白色对象。</p></li><li><p><strong>分代回收：</strong> Go 语言的垃圾回收器采用了分代回收策略，将堆中的对象分为几个代（generation）。新分配的对象会被分配到年轻代，经过多次垃圾回收后仍然存活的对象会被晋升到老年代。由于年轻代的对象生命周期较短，因此可以采用更频繁的垃圾回收策略，而老年代的对象则采用更慢的垃圾回收策略，以提高性能。</p></li><li><p><strong>写屏障：</strong> Go 语言的垃圾回收器使用写屏障技术，记录对象的写入操作，以便在垃圾回收过程中正确识别对象的引用关系。写屏障会在写入指针时触发，将被修改的对象标记为灰色，并将新写入的指针加入标记队列。</p></li></ol><h3 id=三色标记的过程>三色标记的过程</h3><p>三色标记法是一种用于标记-清除（mark-sweep）垃圾回收算法的优化技术，它将对象的标记状态分为三种颜色：白色、灰色和黑色。以下是三色标记法的基本过程：</p><ol><li><p><strong>初始标记（Initial Mark）：</strong> 在初始标记阶段，垃圾回收器从根对象开始，标记所有直接可达的对象为灰色，并将它们加入标记队列。根对象通常是全局变量、栈上的变量以及活跃的协程等。</p></li><li><p><strong>并发标记（Concurrent Mark）：</strong> 在并发标记阶段，垃圾回收器并发地遍历堆中的对象图，标记所有可达的对象为灰色，并将其子对象加入标记队列。如果发现新的灰色对象，将其标记为黑色，并将其子对象加入标记队列。</p></li><li><p><strong>重新标记（Re-Mark）：</strong> 在并发标记过程中，程序可能会产生新的对象，这些新对象可能会在标记过程中被修改，因此需要重新标记。重新标记阶段会对之前标记的所有灰色对象进行重新扫描，将其子对象加入标记队列，并标记为黑色。</p></li><li><p><strong>清除（Sweep）：</strong> 在清除阶段，垃圾回收器扫描整个堆，清除所有未被标记的白色对象，并将它们释放回内存池。清除过程是并发执行的，不会阻塞程序的执行。</p></li></ol><h2 id=其他>其他</h2><h3 id=go-中的-make-和-new-的区别>Go 中的 make 和 new 的区别</h3><p>在 Go 语言中，<code>make</code> 和 <code>new</code> 都是用于创建数据结构的内置函数，但它们的使用场景和作用不同。</p><ol><li><p><strong>make：</strong></p><ul><li><code>make</code> 函数主要用于创建 slice、map 和 channel 这三种引用类型的数据结构，并且返回的是一个初始化之后的数据结构。</li><li>例如，使用 <code>make</code> 函数创建一个长度为 5 的整型 slice：<code>s := make([]int, 5)</code></li><li><code>make</code> 函数的签名为：<code>func make(t Type, size ...IntegerType) Type</code>，其中 <code>t</code> 表示数据结构的类型，<code>size</code> 表示数据结构的大小或者容量（对于 slice 和 channel）。</li></ul></li><li><p><strong>new：</strong></p><ul><li><code>new</code> 函数用于创建某种类型的指针，并且返回该类型的指针的零值，即指向该类型的新分配的零值的指针。</li><li>例如，使用 <code>new</code> 函数创建一个整型指针：<code>p := new(int)</code></li><li><code>new</code> 函数的签名为：<code>func new(Type) *Type</code>，其中 <code>Type</code> 表示要创建的类型。</li></ul></li></ol><p>总的来说，<code>make</code> 用于创建引用类型的数据结构，返回的是一个已初始化的数据结构；而 <code>new</code> 用于创建某种类型的指针，返回的是该类型的零值的指针。</p><h3 id=在-defer-中修改了局部变量并-return返回值为类型和变量类型两种情况下会返回什么>在 defer 中修改了局部变量并 return，返回值为类型和(变量+类型)两种情况下会返回什么</h3><p>在 Go 中，<code>defer</code> 语句中对局部变量的修改对函数的返回值没有影响。无论函数返回值是单个变量还是多个变量（包括变量及其类型），在 <code>defer</code> 中对局部变量的修改不会影响函数返回值。这是因为 Go 在函数返回时会将函数的返回值保存在栈中，并不会受到 <code>defer</code> 中对变量的修改影响。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2024-07-07&nbsp;<a class=git-hash href=https://github.com/pjimming/blog/commit/02e978f0a52e89cc5f9af7fab75dce874e75226e target=_blank title="commit by panjiangming(panjiangming@kuaishou.com) 02e978f0a52e89cc5f9af7fab75dce874e75226e: update cdn">
<i class="fas fa-hashtag fa-fw" aria-hidden=true></i>02e978f</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/2024-03-11/golang/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://blog.pjmcode.top/2024-03-11/golang/ data-title=面试题精选--Golang篇 data-hashtags=interview,golang><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://blog.pjmcode.top/2024-03-11/golang/ data-hashtag=interview><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://blog.pjmcode.top/2024-03-11/golang/ data-title=面试题精选--Golang篇><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://blog.pjmcode.top/2024-03-11/golang/ data-title=面试题精选--Golang篇><i data-svg-src=/lib/simple-icons/icons/line.min.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://blog.pjmcode.top/2024-03-11/golang/ data-title=面试题精选--Golang篇 data-image=https://cdn.jsdelivr.net/gh/pjimming/picx-images-hosting@master/image.9nzjdzppc1.webp><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/interview/>Interview</a>,&nbsp;<a href=/tags/golang/>Golang</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2024-03-09/build-0/ class=prev rel=prev title="零成本搭建个人博客系列--第一篇 为什么选择Hugo？"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>零成本搭建个人博客系列--第一篇 为什么选择Hugo？</a>
<a href=/2024-03-11/mysql/ class=next rel=next title=面试题精选--MySQL篇>面试题精选--MySQL篇<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app>Giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><span id=run-time></span></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/pjimming/ target=_blank>潘江明</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=备案编号" target=_blank>浙ICP备2024074882号</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/plugins/zoom/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{giscus:{category:"Announcements",categoryId:"DIC_kwDOLZmgDc4Cdm7x",darkTheme:"preferred_color_scheme",emitMetadata:"0",inputPosition:"top",lang:"zh-CN",lazyLoading:!1,lightTheme:"light",mapping:"pathname",reactionsEnabled:"1",repo:"pjimming/blog-comment",repoId:"R_kgDOLZmgDQ"}},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript src=https://cdn.staticfile.net/jquery/2.2.4/jquery.min.js></script><script type=text/javascript src=/js/custom.js></script></body></html>